[{"categories":["競技プログラミング"],"contents":"競技プログラミングでアルゴリズムを初めて学ぶ人にとって最初の壁となるのがbit全探索だと思います。僕自身、初めて学んだアルゴリズムがbit全探索であり、色々苦労しました。\nこの記事では、そのbit全探索について数学用語のみの簡潔な説明だけではなく、分かりやすく説明したいと思います。\nなお、前提知識として 2進数・10進数の基本知識 、 ビットの基本演算(シフト演算、AND演算) を理解していると、より理解が深まると思います。\nはじめに まず、bit全探索について一言で説明すると\n複数あるものから、「いくつか選ぶ方法」を全列挙して探索するアルゴリズム\nとなります。これから例題を通して、bit全探索のイメージをつかんでいきましょう。\nまずは例題から 手始めに 例題1 を考えましょう。\n例題1 【問題】\n3個の整数 $0,1,2$ が与えられたとき、その中からいくつか選ぶ方法を列挙せよ。\nこの問題はどのように全探索をすれば良いでしょうか。\n単純な全探索の解法として、forループで列挙することができます。\n3個ある整数ごとに数字を 「選ぶ」「選ばない」 の2通りの選択肢が存在します。つまり、3個の整数 $0,1,2$ について\n$0$ を選ぶ or $0$ を選ばない $1$ を選ぶ or $1$ を選ばない $2$ を選ぶ or $2$ を選ばない の選択肢が存在します。この3つの選択肢の組み合わせを全探索すればいいので、以下のような3重のforループを書くことで全探索することができ、この問題を解くことができます。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 int cnt = 1; for(int i = 0; i \u0026lt; 2; i++){ for(int j = 0; j \u0026lt; 2; j++){ for(int k = 0; k \u0026lt; 2; k++){ vector\u0026lt;int\u0026gt; S; if(k == 1) S.push_back(0); if(j == 1) S.push_back(1); if(i == 1) S.push_back(2); cout \u0026lt;\u0026lt; cnt \u0026lt;\u0026lt; \u0026#34;: \u0026#34;; for(auto\u0026amp;\u0026amp; s: S) cout \u0026lt;\u0026lt; s \u0026lt;\u0026lt; \u0026#34; \u0026#34;; cout \u0026lt;\u0026lt; endl; cnt++; } } } 1: 2: 0 3: 1 4: 0 1 5: 2 6: 0 2 7: 1 2 8: 0 1 2 結局、bit全探索はなんなのか 例題1はforループで全探索しましたが、実はbit全探索の場合でも全く同じ方針で考えて全探索をすることができます。bit全探索は\n複数あるものから 「選ぶ」「選ばない」 などの 2通りある選択肢の選び方がある場合、あり得る選び方を全探索しなければならない問題 に使うことができるのです！\n先程は「3個の整数」から「選ぶ」「選ばない」の 2通りある選択肢の選び方 を全列挙しましたが、より一般的には 複数あるものの各々について「選ぶ・選ばない」の組み合わせを全列挙する ことができるようになるのです。\n具体例として、例題1の3つの整数0, 1, 2をいくつか選ぶ方法は下図のように $2^3 = 8$ 通りの組み合わせがあります。\n一般に $N$ 個のものからいくつか選ぶ方法は $2^N$ 通りありますので覚えておきましょう。\nつまり、先程の条件を言い換えると\n$2^N$ 通りある「いくつか選ぶ方法」を全探索しなければならない問題 に使うことができます。\n結局のところ、bit全探索の正体は \u0026ldquo;全探索\u0026quot;と名前についてある通り、全探索を行うだけ のとってもシンプルなアルゴリズムなのです！！！\nforループでは解けない問題 次にこちらの例題2を考えていきます。\n例題2 【問題】\n$N$ 個の整数 $A_1,A_2, \\dots,A_N$ が与えられたとき、その中からいくつか選ぶ方法を列挙せよ。\n【制約】\n$N \\leq 20$\n例題2は例題1よりも $N$ の制約が緩くなりました。(例題1は $N=3$ の場合です)\nこの問題を先程と同じようにforループで解こうとすると、$N$ 重のfor文が必要になります。また、 $N$ の値は変わるのでfor文の数を固定して書くことができません。\n1 2 3 4 5 6 7 8 9 10 11 for(int i = 0; i \u0026lt; 2; i++){ for(int j = 0; j \u0026lt; 2; j++){ for(int k = 0; k \u0026lt; 2; k++){ for(int l = 0; l \u0026lt; 2; l++){ for(int m = 0; m \u0026lt; 2; m++){ // ... これでは解くことができない } } } } } では、例題2はどのようにして解けば良いのでしょうか。\n先程、bit全探索は $2^N$ 通りの「いくつか選ぶ方法」を全探索しなければならない問題 に使うことができると説明しましたが、この $N$ の数が 入力によって変化する場合 でもbit全探索は使うことができます！\nbit全探索の実装 早速、例題2を解くためのbit全探索を実装していきましょう。基本的な実装方針は以下の通りです。\n💡 方針 手順1: 「いくつか選ぶ方法」を2進数で表し、全探索しやすいように2進数→10進数に変換して整数値にする 手順2: 整数値→2進数に再び変換し、「いくつか選ぶ方法」を復元する 手順3: 復元した「いくつか選ぶ方法」について処理を行う 手順4: 手順1-3を $2^N$ 通り全てに行う すなわち、\n複数のものから「いくつか選ぶ方法」( $\\{0,2\\}$ など) 整数値( $5$ など) の2つを対応させることで整数値での全探索を簡単に行えるようにする、ということです！\nいくつか選ぶ方法を2進数で表す はじめに、「いくつか選ぶ方法」を2進数で表す方法を考えます。例えば、 $\\{0,1,2\\}$ に対して $\\{1,2\\}$ を選ぶ方法は\n1番目の $0$ : 選ばない 2番目の $1$ : 選ぶ 3番目の $2$ : 選ぶ となっており、これを2進数で復元するとき 選ぶときを1、選ばないときを0 とすると $N$ 桁の2進数で $011_{(2)}$ と表すことができます。つまり、\n$i$ 番目のものを選ぶなら、2進数の $i$ 桁目を1にする $i$ 番目のものを選ばないなら、2進数の $i$ 桁目を0にする だけで「いくつか選ぶ方法」を2進数で表すことができるようになったのです！\n2進数→10進数の整数値に変換する 次に、選ぶ方法を表した2進数を10進数へと変換させ、整数値にします。\n0,1,2の8通りの選び方について、2進数と10進数の整数値ではこのように表すことができます。\nbit全探索するためのfor文 $2^N$ 個ある「いくつか選ぶ方法」1つ1つを整数値 $0,1,2,\u0026hellip;,2^N-1$ に対応したことでforループを用いて簡単に全探索することができます。以下の部分は「いくつか選ぶ方法」を整数値に対応付けて全探索を行っていることを表しています。\n1 2 3 for(int bit = 0; bit \u0026lt; (1 \u0026lt;\u0026lt; N); bit++){ /* 「いくつか選ぶ方法」を整数値で表したものに対して処理 */ } コード内の 1 \u0026lt;\u0026lt; N は1をN桁左シフトした値 = $2^N$ のことです。 整数値→2進数に変換し、選ぶ方法を復元する 「いくつか選ぶ方法」を整数値に対応させましたが、このままだとその整数が「どう選ぶことを意味しているのか」が分からないので、先程と逆のことを行い復元します。つまり、\n整数値 $0,1,2,\u0026hellip;,2^N-1$ を再び2進数で表す 2進数で表される「いくつか選ぶ方法」において、 $1 \\leq i \\leq N$ を満たす $i$ について、「 $i$ 番目のものを選んだかどうか」を判定する ことを行います。以下の部分は整数値から「いくつか選ぶ方法」を復元しているのです。\n1 2 3 4 // bitのi桁目(i番目のもの)は1(選んだ)かどうか if((bit \u0026gt;\u0026gt; i) \u0026amp; 1){ /* 選んだものに対して処理 */ } このif文は整数値 $0,1,2,\u0026hellip;,2^N-1$ それぞれについて、\n再び2進数で表したとき、 $i$ 桁目が1かどうか( $i$ 番目のものを選んだかどうか) を判定しています。\n例えば、$N=3,\\text{bit} = 4$ のとき、if((bit \u0026gt;\u0026gt; i) \u0026amp; 1) はどのように判定を行うのか考えます。\n$\\text{bit}$ を2進数で表すと $101_{(2)}$ になるので $i = 0,1,2$ のときの判定は以下の通りです。\ni (bit \u0026gt;\u0026gt; i) ((bit \u0026gt;\u0026gt; i) \u0026amp; 1) 判定 0 101 101 \u0026amp; 001 = 001 True 1 010 010 \u0026amp; 001 = 000 False 2 001 001 \u0026amp; 001 = 001 True (bit \u0026gt;\u0026gt; i)は2進数の $\\text{bit}$ を $i$ 桁右シフトした値であり、これと $1$ をAND演算で判定をすることで\n$ \\text{bit}$ の $i$ 桁目の値が1のとき、True $ \\text{bit}$ の $i$ 桁目の値が0のとき、False となります。実際は $1$ とAND演算することにより最下位bitを残して全て0にできるので、\n$ \\text{bit}$ の $i$ 桁右シフトした値の最下位bitが1なら、True (最下位bit以外の全ての桁は0) $ \\text{bit}$ の $i$ 桁右シフトした値の最下位bitが0なら、False (全ての桁は0) と判定していることになります。\nよって、「いくつか選ぶ方法」を復元するためには、以下のように先程の判定をforループで全てのものに対して行えば良いです。\n1 2 3 4 5 for(int i = 0; i \u0026lt; N; i++){ if((bit \u0026gt;\u0026gt; i) \u0026amp; 1){ /* 選んだものに対して処理 */ } } 実装 長くなりましたが、例題をbit全探索で実装すると以下の通りになります！\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 // N: 何個のものについて考えているか // bit: 選び方の集合を表す整数値 int N = 3; // 3つの整数についてなので N = 3 // 2^N通りの選び方を 0,1,2,...,2^N-1 の整数値に対応させ、全探索 for(int bit = 0; bit \u0026lt; (1 \u0026lt;\u0026lt; N); bit++){ // 2進数で表した「いくつか選ぶ方法」Sを求める vector\u0026lt;int\u0026gt; S; // 各iに対して for(int i = 0; i \u0026lt; N; i++){ // bitのi桁目は1(選んだ)かどうか if((bit \u0026gt;\u0026gt; i) \u0026amp; 1){ S.push_back(i); // 選んだならSに追加する } } // 「いくつか選ぶ方法」Sの出力 cout \u0026lt;\u0026lt; bit \u0026lt;\u0026lt; \u0026#34;: \u0026#34;; for(auto\u0026amp;\u0026amp; v: S) cout \u0026lt;\u0026lt; v \u0026lt;\u0026lt; \u0026#34; \u0026#34;; cout \u0026lt;\u0026lt; endl; } 0: 1: 0 2: 1 3: 0 1 4: 2 5: 0 2 6: 1 2 7: 0 1 2 if((bit \u0026gt;\u0026gt; i) \u0026amp; 1)はif(bit \u0026amp; (1 \u0026lt;\u0026lt; i))と書くこともできますが、本質は同じです。\n実際の問題では配列Sを作成することはほとんどありませんが、その代わりに\n各 $i = 0, 1,\\dots ,N-1$ に対して $i$ が2進数で表される「いくつか選ぶ方法」に含まれていることが分かったら それに応じた処理をその場で行う という場合がほとんどです。\nまた、他にも2進数のbitに対して頻出な判定の書き方は以下の通りです。\n判定 書き方 bitのi桁目が1かどうか\n(i番目を選んだかどうか) if((bit \u0026gt;\u0026gt; i) \u0026amp; 1) bitのi桁目が1ではないかどうか\n(i番目を選んでいないかどうか) if(!((bit \u0026gt;\u0026gt; i) \u0026amp; 1)) bitの1の個数\n(選んだ個数) __builtin_popcount(bit) 計算量について この先、アルゴリズムを学んでいく上で避けては通れないのは 計算量 の存在です。(計算量については今回は説明を省略します。)\n「いくつか選ぶ方法」というのは $2^N$ 通りありますが、すなわち $N$ の値が大きくなると「いくつか選ぶ方法」の数も爆発的に増加するということになります。具体的な処理にもよりますが、 bit全探索が行えるのは $N \\leq 20$ くらいの小さい $N$ が限界です。 計算量だと $O(N 2^N)$ となります。\n実践問題 一通りbit全探索について理解したところで1問、bit全探索で解いてみましょう。\n部分和問題 https://algo-method.com/tasks/1083\n【問題】\n$N$ 個の整数 $A_0, A_1, \\dots ,A_{N-1}$ と、整数 $V$ が与えられます。 これらの整数の中から、いくつかの整数を選んで総和をとります。 総和を $V$ にすることが可能かどうかを判定してください。\n【制約】\n$ 1\\leq N\\leq 16$ $1\\leq V\\leq 10^8$ $1\\leq A_i\\leq V (0 \\leq i\\leq N-1)$ 部分和問題という超ド定番の問題です。これを今回はbit全探索を用いて解いていきましょう。\n$N$ 個の整数の中からいくつかの整数を選ぶ方法は $2^N$ 通りあるので、bit全探索が使えるということになります。\nbit全探索でいくつかの整数を選ぶ方法を全探索する 選んだ整数の総和を求めて、その値が $V$ になるのかを判定する の2ステップでこの問題を解くことができます。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; int main(){ int N, V; cin \u0026gt;\u0026gt; N \u0026gt;\u0026gt; V; vector\u0026lt;int\u0026gt; A(N); for(int i = 0; i \u0026lt; N; i++) cin \u0026gt;\u0026gt; A[i]; bool flag = false; for(int bit = 0; bit \u0026lt; (1 \u0026lt;\u0026lt; N); bit++){ int sum = 0; for(int i = 0; i \u0026lt; N; i++){ if((bit \u0026gt;\u0026gt; i) \u0026amp; 1){ sum += A[i]; } } if(sum == V) flag = true; } if(flag) cout \u0026lt;\u0026lt; \u0026#34;Yes\u0026#34; \u0026lt;\u0026lt; endl; else cout \u0026lt;\u0026lt; \u0026#34;No\u0026#34; \u0026lt;\u0026lt; endl; } 先程の実装では、数字の「いくつか選ぶ方法」の配列Sを作成していましたが、\n$i$ 番目のものを選んだかどうか」を判定する 選んだなら変数sumに足す(処理を行う) を同時に行う実装をするのが自然です。\n練習問題 bit全探索で解ける問題を置いておきます。 bit全探索例題\n参考文献 ビット演算 (bit 演算) の使い方を総特集！ 〜 マスクビットから bit DP まで 〜 - Qiita bit 全探索 - けんちょんの競プロ精進記録 ビット全探索（ 2^n 通りの全探索） | アルゴリズムロジック こわくないbit全探索1 入門編: bit全探索ってなに？【競プロ解説】 - Qiita ","date":"Jan 09","permalink":"https://jikky.dev/post/bit-search/","tags":["競技プログラミング"],"title":"bit全探索をココロから理解する"},{"categories":null,"contents":" Github: @Jikky1618 Twitter: @Jikky1618 AtCoder: Jikky1618 Scratch: @-Jikky- 今は競プロに熱中しすぎて、あんまり活動していません。 note: じっきー 色変記事などはこちらに投稿する予定です。 Discord: Jikky#1618 Scratch JPというScratcherが集まるサーバーを運営しています。 ","date":"Jan 08","permalink":"https://jikky.dev/contact/","tags":null,"title":"Contact"},{"categories":null,"contents":"","date":"Jan 01","permalink":"https://jikky.dev/articles/","tags":null,"title":"Articles"}]
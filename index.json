[{"categories":["競技プログラミング"],"contents":"競技プログラミングでアルゴリズムを初めて学ぶ人にとって最初の壁となるのがbit全探索だと思います。僕自身、初めて学んだアルゴリズムがbit全探索であり、色々苦労しました。\nこの記事では、そのbit全探索について数学用語のみの簡潔な説明だけではなく、分かりやすく説明したいと思います。\nなお、前提知識として 2進数・10進数の基本知識 、 ビット演算(シフト演算、AND演算) を理解していると、より理解が深まると思います。\nbit全探索とは まず、bit全探索について一言で説明すると\n$2^N$ 通りの $N$ 個のものから、いくつか選んだ組合せを全探索するアルゴリズム\nとなります。これだけ言われてもよくわからないと思うので、例を通して説明していきます。\nまずは例から $N$ 個のものから、いくつか選んだ組合せをいきなり考えるのは難しいので、 より簡単な例題1を考えましょう。\n例題1 【問題】\n3個の整数 $0,1,2$ が与えられたとき、その中からいくつか選ぶ方法を列挙せよ。\n頑張って表に書き出すと $8$ 通りあることが分かります。\nなぜ $8$ 通りなのかを知るために整数がどのように選ばれているのかを考えます。\n3個の整数 $0,1,2$ は\n$0$ を選ぶ or $0$ を選ばない $1$ を選ぶ or $1$ を選ばない $2$ を選ぶ or $2$ を選ばない の選択肢が存在します。つまり、1つの整数ごとに選択肢が2通り存在します。\nよって、表に書いた通り, 3個の整数の中からいくつか選ぶ方法は $2^3 = 8$ 通り存在します。一般に $N$ 個のものからいくつか選ぶ方法は $2^N$ 通り存在することが知られています。\nこのような\n複数あるものから 「選ぶ」「選ばない」 などの 2通りある選択肢の選び方がある場合、 $2^N$ 通り存在する選び方を全列挙する1 みたいな問題を実装するときにbit全探索を使うことで簡潔に実装することができます。\nforループで解けない問題 続いて、こちらの例題2を考えていきます。\n例題2 【問題】\n$N$ 個の整数 $A_1,A_2, \\dots,A_N$ が与えられたとき、その中からいくつか選ぶ方法を列挙せよ。\n【制約】\n$N \\leq 20$\n例題2は例題1よりも $N$ の制約が緩くなりました。(例題1は $N=3$ の場合です)\nこの問題を愚直にforループで解こうとすると、$N$ 重のfor文が必要になります。また、 $N$ の値は変わるのでfor文の数を固定して書くことができません。\n1 2 3 4 5 6 7 8 9 10 11 for(int i = 0; i \u0026lt; 2; i++){ for(int j = 0; j \u0026lt; 2; j++){ for(int k = 0; k \u0026lt; 2; k++){ for(int l = 0; l \u0026lt; 2; l++){ for(int m = 0; m \u0026lt; 2; m++){ // ... for文の個数が分からない } } } } } ここで例題2を解くbit全探索を実装していきましょう。\nbit全探索の実装 bit全探索の基本的な実装方針は以下の通りです。\n💡 方針 手順1: 「いくつか選ぶ方法」を2進数で表し、全探索しやすいように2進数→10進数に変換して整数値にする 手順2: 整数値→2進数に再び変換し、「いくつか選ぶ方法」を復元する 手順3: 復元した「いくつか選ぶ方法」について処理を行う 手順4: 手順1-3を $2^N$ 通り全てに行う すなわち、\n複数のものから「いくつか選ぶ方法」( $\\{0,2\\}$ など) 整数値( $5$ など) の2つを対応させることで、整数値で全探索を行えるようにしていきます。\nいくつか選ぶ方法を2進数で表す はじめに、「いくつか選ぶ方法」を2進数で表す方法を考えます。例えば、 $\\{0,1,2\\}$ に対して $\\{1,2\\}$ を選ぶ方法は\n1番目の $0$ : 選ばない 2番目の $1$ : 選ぶ 3番目の $2$ : 選ぶ となっており、これを2進数で復元するとき 選ぶときを1、選ばないときを0 とすると $N$ 桁の2進数で $110_{(2)}$ と表すことができます。つまり、\n$i$ 番目のものを選ぶなら、2進数の $i$ 桁目を1にする $i$ 番目のものを選ばないなら、2進数の $i$ 桁目を0にする だけで「いくつか選ぶ方法」を2進数で表すことができるようになったのです！\n2進数→10進数の整数値に変換する 次に、選ぶ方法を表した2進数を10進数へと変換させ、整数値にします。\n0,1,2の8通りの選び方について、2進数と10進数の整数値ではこのように表すことができます。\nbit全探索するためのfor文 $2^N$ 個ある「いくつか選ぶ方法」1つ1つを整数値 $0,1,2,\u0026hellip;,2^N-1$ に対応したことでforループを用いて簡単に全探索することができます。以下の部分は「いくつか選ぶ方法」を整数値に対応付けて全探索を行っていることを表しています。\n1 2 3 for(int bit = 0; bit \u0026lt; (1 \u0026lt;\u0026lt; N); bit++){ /* 「いくつか選ぶ方法」を整数値で表したものに対して処理 */ } コード内の 1 \u0026lt;\u0026lt; N は1をN桁左シフトした値 = $2^N$ のことです。 整数値→2進数に変換し、選ぶ方法を復元する 「いくつか選ぶ方法」を整数値に対応させましたが、このままだとその整数が「どう選ぶことを意味しているのか」が分からないので、先程と逆のことを行い復元します。つまり、\n整数値 $0,1,2,\u0026hellip;,2^N-1$ を再び2進数で表す $1 \\leq i \\leq N$ を満たす $i$ について、2進数で表される「いくつか選ぶ方法」から「 $i$ 番目のものを選んだかどうか」を判定する ことを行います。以下の部分は整数値から「いくつか選ぶ方法」を復元しているのです。\n1 2 3 4 // bitのi桁目(i番目のもの)は1(選んだ)かどうか if((bit \u0026gt;\u0026gt; i) \u0026amp; 1){ /* 選んだものに対して処理 */ } このif文は整数値 $0,1,2,\u0026hellip;,2^N-1$ それぞれについて、\n再び2進数で表したとき、 $i$ 桁目が1かどうか( $i$ 番目のものを選んだかどうか) を判定しています。\n例えば、$N=3,\\text{bit} = 5$ のとき、if((bit \u0026gt;\u0026gt; i) \u0026amp; 1) はどのように判定を行うのか考えます。\n$\\text{bit}$ を2進数で表すと $101_{(2)}$ になるので $i = 0,1,2$ のときの判定は以下の通りです。\ni (bit \u0026gt;\u0026gt; i) ((bit \u0026gt;\u0026gt; i) \u0026amp; 1) 判定 0 101 101 \u0026amp; 001 = 001 True 1 010 010 \u0026amp; 001 = 000 False 2 001 001 \u0026amp; 001 = 001 True (bit \u0026gt;\u0026gt; i)は2進数の $\\text{bit}$ を $i$ 桁右シフトした値であり、これと $1$ をAND演算で判定をすることで\n$\\text{bit}$ の $i$ 桁目の値が1のとき、True $\\text{bit}$ の $i$ 桁目の値が0のとき、False となります。実際は $1$ とAND演算することにより最下位bitを残して全て0にできるので、\n$\\text{bit}$ の $i$ 桁右シフトした値の最下位bitが1なら、True (最下位bit以外の全ての桁は0) $\\text{bit}$ の $i$ 桁右シフトした値の最下位bitが0なら、False (全ての桁は0) を判定していることになります。\nよって、「いくつか選ぶ方法」を復元するためには、以下のように先程の判定をforループで全てのものに対して行えば良いです。\n1 2 3 4 5 for(int i = 0; i \u0026lt; N; i++){ if((bit \u0026gt;\u0026gt; i) \u0026amp; 1){ /* 選んだものに対して処理 */ } } 以上のことを踏まえて例題2をbit全探索で実装すると以下の通りになります！\nコード 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; int main(){ // N: 何個のものについて考えているか // bit: 選び方の集合を表す整数値 int N; cin \u0026gt;\u0026gt; N; // 2^N通りの選び方を 0,1,2,...,2^N-1 の整数値に対応させ、全探索 for(int bit = 0; bit \u0026lt; (1 \u0026lt;\u0026lt; N); bit++){ // 選んだものを管理する配列S vector\u0026lt;int\u0026gt; S; // 各iに対して for(int i = 0; i \u0026lt; N; i++){ // bitのi桁目は1(選んだ)かどうか if((bit \u0026gt;\u0026gt; i) \u0026amp; 1){ S.push_back(i); // 選んだならSに追加する } } // 配列Sの出力 cout \u0026lt;\u0026lt; bit \u0026lt;\u0026lt; \u0026#34;: \u0026#34;; for(auto\u0026amp;\u0026amp; v: S) cout \u0026lt;\u0026lt; v \u0026lt;\u0026lt; \u0026#34; \u0026#34;; cout \u0026lt;\u0026lt; endl; } } 出力 1 2 3 4 5 6 7 8 0: 1: 0 2: 1 3: 0 1 4: 2 5: 0 2 6: 1 2 7: 0 1 2 if((bit \u0026gt;\u0026gt; i) \u0026amp; 1)はif(bit \u0026amp; (1 \u0026lt;\u0026lt; i))と書くこともできますが、本質は同じです。 また、他にも2進数のbitに対して頻出な判定の書き方は以下の通りです。\n判定 書き方 bitの $i$ 桁目が1か if((bit \u0026gt;\u0026gt; i) \u0026amp; 1) bitの $i$ 桁目が1でないか if(!((bit \u0026gt;\u0026gt; i) \u0026amp; 1)) bitの1の個数 __builtin_popcount(bit) 計算量について この先、アルゴリズムを学んでいく上で避けては通れないのは 計算量 の存在です。(計算量については今回は説明を省略します。)\n「いくつか選ぶ方法」というのは $2^N$ 通りありますが、これは指数的に増加します。すなわち $N$ の値が大きくなると「いくつか選ぶ方法」の数も爆発的に増加するということになります。具体的な処理にもよりますが、 bit全探索が行えるのは $N \\leq 20$ くらいの小さい値が限界です。 計算量だと $O(N 2^N)$ となります。\n実践問題 一通りbit全探索について理解したところで1問、bit全探索で解いてみましょう。\n部分和問題 https://algo-method.com/tasks/1083\n【問題】\n$N$ 個の整数 $A_0, A_1, \\dots ,A_{N-1}$ と、整数 $V$ が与えられます。 これらの整数の中から、いくつかの整数を選んで総和をとります。 総和を $V$ にすることが可能かどうかを判定してください。\n【制約】\n$ 1\\leq N\\leq 16$ $1\\leq V\\leq 10^8$ $1\\leq A_i\\leq V (0 \\leq i\\leq N-1)$ 部分和問題という超ド定番の問題です。これを今回はbit全探索を用いて解いていきましょう。\n$N$ 個の整数の中からいくつかの整数を選ぶ方法は $2^N$ 通りあるので、bit全探索が使えるということになります。\nbit全探索でいくつかの整数を選ぶ方法を全探索する 選んだ整数の総和を求めて、その値が $V$ になるのかを判定する の2ステップでこの問題を解くことができます。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; int main(){ // 入力 int N, V; cin \u0026gt;\u0026gt; N \u0026gt;\u0026gt; V; vector\u0026lt;int\u0026gt; A(N); for(int i = 0; i \u0026lt; N; i++) cin \u0026gt;\u0026gt; A[i]; // bit全探索で部分和を全て求める bool flag = false; // 可能かどうかを管理する変数flag for(int bit = 0; bit \u0026lt; (1 \u0026lt;\u0026lt; N); bit++){ int sum = 0; for(int i = 0; i \u0026lt; N; i++){ if((bit \u0026gt;\u0026gt; i) \u0026amp; 1){ // もしi番目を選んだなら sum += A[i]; // sumにA_iを足す } } // 部分和とVが等しいか判定 if(sum == V) flag = true; } // 出力 if(flag) cout \u0026lt;\u0026lt; \u0026#34;Yes\u0026#34; \u0026lt;\u0026lt; endl; else cout \u0026lt;\u0026lt; \u0026#34;No\u0026#34; \u0026lt;\u0026lt; endl; } 先程の実装では、数字の「いくつか選ぶ方法」の配列Sを作成していましたが、実際の問題では配列Sを作成することはほとんどありません。その代わりに\n$0 \\leq i \u0026lt; N$ を満たす $i$ について、 $i$ 番目のものが $\\text{bit}$ に含まれているなら、 それに応じた処理をその場で行う 場合がほとんどです。今回の部分和問題では\n$i$ 番目のものを選んだかどうかを判定する 選んだなら変数sumに足す を同時に行う実装をしています。\nさいごに 初めてで拙い文章になってしまいましたが、この記事で1人でもbit全探索の理解に繋がったのであれば嬉しいです。参考文献の記事も僕自身、学習の参考にさせてもらったものですので、是非そちらの記事も確認してみてください。\n練習問題 ビット演算 | アルゴ式 : ビットの説明からbit全探索まで全てをカバーしている素晴らしい問題集です。 bit全探索例題 : bit全探索で解けるAtCoderの問題の簡易的な説明と実装コードです。 参考文献 ビット演算 (bit 演算) の使い方を総特集！ 〜 マスクビットから bit DP まで 〜 - Qiita bit 全探索 - けんちょんの競プロ精進記録 ビット全探索（ 2^n 通りの全探索） | アルゴリズムロジック こわくないbit全探索1 入門編: bit全探索ってなに？【競プロ解説】 - Qiita $N$ 個の要素を持つ集合 $\\{0, 1, 2, \\dots, N-1\\}$ の部分集合を全列挙することと同じ意味です。\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n","date":"Jan 09","permalink":"https://jikky.dev/post/bit-search/","tags":["競技プログラミング"],"title":"bit全探索をココロから理解する"},{"categories":null,"contents":" Github: @Jikky1618 Twitter: @Jikky1618 AtCoder: Jikky1618 Scratch: @-Jikky- 今は競プロに熱中しすぎて、あんまり活動していません。 note: じっきー 色変記事などはこちらに投稿する予定です。 Discord: Jikky#1618 Scratch JPというScratcherが集まるサーバーを運営しています。 ","date":"Jan 08","permalink":"https://jikky.dev/contact/","tags":null,"title":"Contact"},{"categories":null,"contents":"","date":"Jan 01","permalink":"https://jikky.dev/articles/","tags":null,"title":"Articles"}]
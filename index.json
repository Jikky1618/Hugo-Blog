[{"categories":["競技プログラミング"],"contents":"競技プログラミングでアルゴリズムを初めて学ぶ人にとって最初の壁となるのがbit全探索だと思います。僕自身、初めて学んだアルゴリズムがbit全探索であり、色々苦労しました。\nこの記事では、そのbit全探索について数学用語のみの簡潔な説明だけではなく、分かりやすく説明したいと思います。\nなお、前提知識として 2進数・10進数の基本知識 、 ビットの基本演算(シフト演算、AND演算) を理解していると、より理解が深まると思います。\nはじめに まず、bit全探索についてとても簡潔に説明すると以下のようになります。\n$N$ 個の要素を持つ集合 $\\{0,1,2,\\dots,N-1\\}$ の部分集合の全列挙を行うアルゴリズム\n「集合って何？部分集合の全列挙って何？」と思われた方がほとんどだと思いますが、安心してください。順を追って理解できるよう説明しますので、まずは簡単な例題で肩慣らしをしましょう。\nまずは例題から 手始めにforループでも解ける簡単な全探索の問題を考えましょう。\n【問題】\n3個の整数 $0,1,2$ が与えられたとき、その中からいくつか選ぶ方法を列挙せよ。\nこの問題はどのように全探索をすれば良いでしょうか。まず、3個ある整数ごとに選択肢としてその数字を 「選ぶ」「選ばない」 の2通りの選択肢が存在します。 3個の整数 $0,1,2$ について\n$0$ を選ぶ or $0$ を選ばない $1$ を選ぶ or $1$ を選ばない $2$ を選ぶ or $2$ を選ばない の選択肢が存在します。この3つの選択肢の組み合わせを全探索すればいいので、このような3重のforループを書くことにより全探索することができ、問題を解くことができました。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 int cnt = 1; for(int i = 0; i \u0026lt; 2; i++){ for(int j = 0; j \u0026lt; 2; j++){ for(int k = 0; k \u0026lt; 2; k++){ vector\u0026lt;int\u0026gt; S; if(k == 1) S.push_back(0); if(j == 1) S.push_back(1); if(i == 1) S.push_back(2); cout \u0026lt;\u0026lt; cnt \u0026lt;\u0026lt; \u0026#34;: \u0026#34;; for(auto\u0026amp;\u0026amp; s: S) cout \u0026lt;\u0026lt; s \u0026lt;\u0026lt; \u0026#34; \u0026#34;; cout \u0026lt;\u0026lt; endl; cnt++; } } } 1: 2: 0 3: 1 4: 0 1 5: 2 6: 0 2 7: 1 2 8: 0 1 2 結局、bit全探索はなんなのか 実は先程の例題はbit全探索の場合でも全く同じ方針で考えることができます。bit全探索は\n複数あるものから 「選ぶ」「選ばない」 などの 2通りある選択肢の選び方がある場合、あり得る選び方を全探索しなければならない問題 に使うことができるのです！\n先程は「3個の整数」から「選ぶ」「選ばない」の 2通りある選択肢の選び方 を全列挙しましたが、ここで、最初に示した説明を分かりやすくするとこうなります。\n複数あるものから、「いくつか選ぶ方法」を全列挙して探索するアルゴリズム\n「いくつか選ぶ方法」の全列挙というのは 複数あるものの各々について「選ぶ・選ばない」の組み合わせを全列挙する ということです。 bit全探索の正体は \u0026ldquo;全探索\u0026quot;と名前についてある通り、 ただの全探索を行うだけ のアルゴリズムなのです！！！\n具体例として、先程の例題の3つの整数0, 1, 2をいくつか選ぶ方法は下図のように $2^3 = 8$ 通りの組み合わせがあります。一般に $N$ 個のものから、いくつか選ぶ方法は $2^N$ 通りありますので覚えておきましょう。\nbit全探索の実装 では、先程の例題をforループではなく、bit全探索で解いていきましょう。基本的にbit全探索を実装するときの方針は以下の通りです。\n💡 方針 「いくつか選ぶ方法」を2進数で表し、全探索しやすいように2進数→10進数に変換して整数値にする 整数値→2進数に再び変換し、「いくつか選ぶ方法」を復元する 復元した「いくつか選ぶ方法」について処理を行う 1-3を $2^N$ 通り全てに行う すなわち、\n複数のものから「いくつか選ぶ方法」( $\\{0,2\\}$ など) 整数値( $5$ など) を対応させることで全探索を簡単に行えるようにする、ということです！\nいくつか選ぶ方法を2進数で表す はじめに、「いくつか選ぶ方法」を2進数で表す方法を考えます。\n例えば、 $\\{0,1,2\\}$ に対して $\\{1,2\\}$ を選ぶ方法は\n1番目の $0$ : 選ばない 2番目の $1$ : 選ぶ 3番目の $2$ : 選ぶ となっており、これを2進数で復元するとき 選ぶときを1、選ばないときを0 とすると $N$ 桁の2進数で $011_{(2)}$ と表すことができます。つまり、\n$i$ 番目のものを選ぶなら、2進数の $i$ 桁目を1にする $i$ 番目のものを選ばないなら、2進数の $i$ 桁目を0にする だけで「いくつか選ぶ方法」を2進数で表すことができるようになったのです！\n2進数→10進数の整数値に変換する 次に、選ぶ方法を表した2進数を10進数へと変換させ、整数値にします。整数値と対応することで非常に扱いやすくなり、全探索がしやすくなります！\n例題の8通りの選び方について、2進数と10進数の整数値ではこのように表すことができます。\nbit全探索するためのfor文 $2^N$ 個ある「いくつか選ぶ方法」を整数値 $0,1,2,\u0026hellip;,2^N-1$ にしたことでforループを用いて簡単に全探索することができます。bit全探索での以下の部分は「いくつか選ぶ方法」を整数値に対応付けて全探索を行っていることを表しているのです！\n1 2 3 for(int bit = 0; bit \u0026lt; (1 \u0026lt;\u0026lt; N); bit++){ /* 「いくつか選ぶ方法」を整数値で表したものに対して処理 */ } コード内の 1 \u0026lt;\u0026lt; N は1をN桁左シフトした値 = $2^N$ のことです。 整数値→2進数に変換し、選ぶ方法を復元する 「いくつか選ぶ方法」を整数値に対応させましたが、このままだとその整数が「どう選ぶことを意味しているのか」が分からないので、先程と逆のことを行い復元します。つまり、\n整数値 $0,1,2,\u0026hellip;,2^N-1$ を再び2進数で表す 2進数で表される「いくつか選ぶ方法」において、 $1 \\leq i \\leq N$ を満たす $i$ について、「 $i$ 番目のものを選んだかどうか」を判定する ことを行います。以下の部分は整数値から「いくつか選ぶ方法」を復元しているのです。\n1 2 3 4 // bitのi桁目(i番目のもの)は1(選んだ)かどうか if((bit \u0026gt;\u0026gt; i) \u0026amp; 1){ /* 選んだものに対して処理 */ } このif文は整数値 $0,1,2,\u0026hellip;,2^N-1$ それぞれについて、\n再び2進数で表したとき、 $i$ 桁目が1かどうか( $i$ 番目のものを選んだかどうか) を判定しています。\n例えば、$N=3,\\text{bit} = 4$ のとき、if((bit \u0026gt;\u0026gt; i) \u0026amp; 1) はどのように判定を行うのか考えます。\n$\\text{bit}$ を2進数で表すと $101_{(2)}$ になるので $i = 0,1,2$ のときの判定は以下の通りです。\ni (bit \u0026gt;\u0026gt; i) ((bit \u0026gt;\u0026gt; i) \u0026amp; 1) 判定 0 101 101 \u0026amp; 001 = 001 True 1 010 010 \u0026amp; 001 = 000 False 2 001 001 \u0026amp; 001 = 001 True (bit \u0026gt;\u0026gt; i)は2進数の $\\text{bit}$ を $i$ 桁右シフトした値であり、これと $1$ をAND演算で判定をすることで\n$ \\text{bit}$ の $i$ 桁目の値が1のとき、True $ \\text{bit}$ の $i$ 桁目の値が0のとき、False となります。実際は $1$ とAND演算することにより最下位bitを残して全て0にできるので、\n$ \\text{bit}$ の $i$ 桁右シフトした値の最下位bitが1なら、True (最下位bit以外の全ての桁は0) $ \\text{bit}$ の $i$ 桁右シフトした値の最下位bitが0なら、False (全ての桁は0) と判定していることになります。\nよって、「いくつか選ぶ方法」を復元するためには、以下のように先程の判定をforループで全てのものに対して行えば良いです。\n1 2 3 4 5 for(int i = 0; i \u0026lt; N; i++){ if((bit \u0026gt;\u0026gt; i) \u0026amp; 1){ /* 選んだものに対して処理 */ } } 実装 長くなりましたが、最初の例題をbit全探索で実装すると以下の通りになります！\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 // N: 何個のものについて考えているか // bit: 選び方の集合を表す整数値 int N = 3; // 3つの整数についてなので N = 3 // 2^N通りの選び方を 0,1,2,...,2^N-1 の整数値に対応させ、全探索 for(int bit = 0; bit \u0026lt; (1 \u0026lt;\u0026lt; N); bit++){ // 2進数で表した「いくつか選ぶ方法」Sを求める vector\u0026lt;int\u0026gt; S; // 各iに対して for(int i = 0; i \u0026lt; N; i++){ // bitのi桁目は1(選んだ)かどうか if((bit \u0026gt;\u0026gt; i) \u0026amp; 1){ S.push_back(i); // 選んだならSに追加する } } // 「いくつか選ぶ方法」Sの出力 cout \u0026lt;\u0026lt; bit \u0026lt;\u0026lt; \u0026#34;: \u0026#34;; for(auto\u0026amp;\u0026amp; v: S) cout \u0026lt;\u0026lt; v \u0026lt;\u0026lt; \u0026#34; \u0026#34;; cout \u0026lt;\u0026lt; endl; } 0: 1: 0 2: 1 3: 0 1 4: 2 5: 0 2 6: 1 2 7: 0 1 2 if((bit \u0026gt;\u0026gt; i) \u0026amp; 1)はif(bit \u0026amp; (1 \u0026lt;\u0026lt; i))と書くこともできますが、本質は同じです。\n実際の問題では配列Sを作成することはほとんどありませんが、その代わりに\n各 $i = 0, 1,\\dots ,N-1$ に対して $i$ が2進数で表される「いくつか選ぶ方法」に含まれていることが分かったら それに応じた処理をその場で行う という場合がほとんどです。\nまた、他にも2進数のbitに対して頻出な判定の書き方は以下の通りです。\n判定 書き方 bitのi桁目が1かどうか\n(i番目を選んだかどうか) if((bit \u0026gt;\u0026gt; i) \u0026amp; 1) bitのi桁目が1ではないかどうか\n(i番目を選んでいないかどうか) if(!((bit \u0026gt;\u0026gt; i) \u0026amp; 1)) bitの1の個数\n(選んだ個数) __builtin_popcount(bit) 計算量について この先、アルゴリズムを学んでいく上で避けては通れないのは 計算量 の存在です。(計算量については今回は説明を省略します。)\n「いくつか選ぶ方法」というのは $2^N$ 通りありますが、すなわち $N$ の値が大きくなると「いくつか選ぶ方法」の数も爆発的に増加するということになります。具体的な処理にもよりますが、 bit全探索が行えるのは $N \\leq 20$ くらいの小さい $N$ が限界です。 計算量だと $O(N 2^N)$ となります。\n練習問題 bit全探索で解ける問題を置いておきます。 bit全探索例題\n参考文献 ビット演算 (bit 演算) の使い方を総特集！ 〜 マスクビットから bit DP まで 〜 - Qiita bit 全探索 - けんちょんの競プロ精進記録 ビット全探索（ 2^n 通りの全探索） | アルゴリズムロジック こわくないbit全探索1 入門編: bit全探索ってなに？【競プロ解説】 - Qiita ","date":"Jan 09","permalink":"https://jikky.dev/post/bit-search/","tags":["競技プログラミング"],"title":"bit全探索についてココロから理解する"},{"categories":["競技プログラミング"],"contents":" 概要 bit全探索とは、$N$ 個のものから「いくつか選ぶ方法」を全列挙して探索するアルゴリズムです。通常のforループでは全探索できない $2^N$ 通りを全探索できるようになります。\n「いくつか選ぶ方法」の全列挙というのは $N$ 個の各々について「選ぶ・選ばない」 を全て列挙するということです。\n簡潔に言うと $N$ 個の要素を持つ集合 ${0,1,2,\\dots,N-1}$ の部分集合の全列挙ができます。\n例題 例題を通して、どのように全探索を行うかを理解しましょう。\n【問題】\n$N$ 個の整数 $A_1,A_2, \\dots,A_N$ が与えられたとき、その中からいくつか選ぶ方法を列挙せよ。\n【制約】\n$N \\leq 20$\nこの問題をforループで解こうとすると、$N$ 重のfor文が必要になります。また、 $N$ の値は変わるのでfor文の数を固定して書くことができません。\nより分かりやすいように先程の例題の $N=3$ のときの場合を考えます。\n【問題】\n3個の整数 $0,1,2$ が与えられたとき、その中からいくつか選ぶ方法を列挙せよ。\n数学が得意な方であれば $2^3 = 8$ 通りあることは容易に分かると思いますが、これはどのようにして導き出したのかを考えていきましょう。\nまず、3個ある整数ごとに選択肢として「選ぶ」「選ばない」の2通りが存在します。 $0,1,2$ について\n$0$ を選ぶ or $0$ を選ばない $1$ を選ぶ or $1$ を選ばない $2$ を選ぶ or $2$ を選ばない が存在します。下図のとおり、 $2^3 = 8$ 通りあることになります。\nこの問題であれば3重のfor文でも全パターンを列挙することは出来ますが、bit全探索を行って全パターンを列挙してみましょう。\nbit全探索の実装 基本的にbit全探索を実装するときの方針は以下の通りです。\nこちらの表現を用いて説明します。\n「いくつか選ぶ方法」を2進数で表したものをbit列 bit列を10進数の整数値に置き換えたものを整数値bit列 💡 方針 いくつか選ぶ方法をbit列(2進数)で表し、bit列→整数値bit列に変換する 整数値bit列→bit列に変換し、選ぶ方法を復元する 復元した選ぶ方法について処理を行う 1-3を $2^N$ 通り全てに行う いくつか選ぶ方法をbit列(2進数)で表す はじめに、「いくつか選ぶ方法」をbit列で表す方法を考えます。\n例えば、 ${0,1,2}$ に対して${1,2}$ を選ぶ方法は ${0,1,2}$ の1番目である $0$ は選ばず、2番目、3番目である $1,2$ を選んでいるので、$N$ 桁のbit列で $011_{(2)}$ と表せます。\nつまり、これだけで「いくつか選ぶ方法」bit列で表すことができます。\n$i$ 番目のものを選ぶなら、bit列の $i$ 桁目を1にする $i$ 番目のものを選ばないなら、bit列の $i$ 桁目を0にする bit列→整数値bit列に変換する 次に、選ぶ方法を表したbit列を10進数に直して整数値bit列に変換します。 これにより、整数値と選び方を対応させることができ、非常に扱いやすくなります！\n例題の8つの選び方について、bit列と整数値bit列ではこのように表すことができます。\nbit全探索するためのfor文 $2^N$ 個ある整数値bit列 $0,1,2,\u0026hellip;,2^N-1$ までをfor文を用いて全探索します。\n先程、整数値と選び方を対応させたことにより、forループで「いくつか選ぶ方法」を全て探索することができるようになりました。\n1 2 3 for(int bit = 0; bit \u0026lt; (1 \u0026lt;\u0026lt; N); bit++){ /* 整数値bitで表した集合に対して、処理 */ } コード内の 1 \u0026lt;\u0026lt; N は1をN桁左シフトした値 = $2^N$ のことです。 整数値bit列→bit列に変換し、選ぶ方法を復元する 「いくつか選ぶ方法」を整数値に対応させましたが、このままだとその整数が「どう選ぶことを意味しているのか」がわからないので、先程と逆のことを行い復元します。つまり、\n整数値bit列 $0,1,2,\u0026hellip;,2^N-1$ を再びbit列で表す bit列で表される「選び方」において、「i番目を選んだかどうか」を判定する ことを行います。以下のコードによって整数値bit列から「いくつか選ぶ方法」を復元しているのです。\n1 2 3 4 5 // 復元処理 // bitのi桁目(i番目のもの)は1(選んだ)かどうか if((bit \u0026gt;\u0026gt; i) \u0026amp; 1){ /* 選んだものに対して処理 */ } このif文は整数値bit列 $0,1,2,\u0026hellip;,2^N-1$ それぞれについて、\n再びbit列で表したとき、 $i$ 桁目が1かどうか( $i$ 番目のものを選んだかどうか) を判定しています。\n例えば、$N=3,\\text{bit} = 4$ のとき、if((bit \u0026gt;\u0026gt; i) \u0026amp; 1) はどのように判定を行うのか考えます。\n$\\text{bit}$ を2進数で表すと $101_{(2)}$ になる、$i = 0,1,2$ のときの判定は以下の通りです。\ni (bit \u0026raquo; i) (bit \u0026raquo; i) \u0026amp; 1) 判定 0 101 101 \u0026amp; 001=001 True 1 010 010 \u0026amp; 001=000 False 2 001 001 \u0026amp; 001=001 True (bit \u0026gt;\u0026gt; i)は $\\text{bit}$ を $i$ 桁右シフトした値であり、これと $1$ をAND演算で判定をすることで\n$ \\text{bit}$ の $i$ 桁目の値が1のとき、True $ \\text{bit}$ の $i$ 桁目の値が0のとき、False となります。$1$ は最下位bit以外全て0になっているので、AND演算によって最下位bitを残して全て0にします。ですので実際は\nbitの $i$ 桁右シフトした値の最下位bitが1なら、True (最下位Bit以外の桁は0) bitの $i$ 桁右シフトした値の最下位bitが0なら、False (全ての桁は0) と判定していることになります。\nbitに対して、頻出な判定の書き方は以下の通りです。\n判定 書き方 bitのi桁目が1かどうか(i番目を選んだかどうか) if((bit \u0026gt;\u0026gt; i) \u0026amp; 1) bitのi桁目が1ではないかどうか(i番目を選んでいないかどうか) if(!((bit \u0026gt;\u0026gt; i) \u0026amp; 1)) bitの1の個数(選んだ個数) __builtin_popcount(bit) 実装 例題の実装は以下の通りです。 $N$ の値を変えればどのような場合でも対応できます。\n計算量 $O(N2^N)$\n$N \\leq 20$ くらいなら間に合います。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 // N: 何個のものについて考えているか // bit: 選び方の集合を表す整数値 int N = 3; // 2^N通りの選び方を 0,1,2,...,2^N-1 の整数値に対応 for(int bit = 0; bit \u0026lt; (1 \u0026lt;\u0026lt; N); bit++){ /* bitで表した集合に対して、処理 */ // bitで表した集合Sを求める vector\u0026lt;int\u0026gt; S; // 各iに対して for(int i = 0; i \u0026lt; N; i++){ // bitのi桁目は1(選んだ)かどうか if((bit \u0026gt;\u0026gt; i) \u0026amp; 1){ S.push_back(i); } } // bitで表した集合Sの出力 cout \u0026lt;\u0026lt; bit \u0026lt;\u0026lt; \u0026#34;: \u0026#34;; for(auto\u0026amp;\u0026amp; v: S){ cout \u0026lt;\u0026lt; v \u0026lt;\u0026lt; \u0026#34; \u0026#34;; } cout \u0026lt;\u0026lt; endl; } 0: 1: 0 2: 1 3: 0 1 4: 2 5: 0 2 6: 1 2 7: 0 1 2 if((bit \u0026gt;\u0026gt; i) \u0026amp; 1)はif(bit \u0026amp; (1 \u0026lt;\u0026lt; i)と書くこともできますが、本質は同じです。\n実際の問題では配列Sを作成することはほとんどありません。その代わり\n各 $i = 0, 1,\\dots$に対して $i$ がbitで表される集合に含まれることが分かったら それに応じた処理をその場で行う という場合がほとんどです。\n練習問題 bit全探索で解ける問題を置いておきます。 bit全探索例題\n参考文献 ビット演算 (bit 演算) の使い方を総特集！ 〜 マスクビットから bit DP まで 〜 - Qiita bit 全探索 - けんちょんの競プロ精進記録 ビット全探索（ 2^n 通りの全探索） | アルゴリズムロジック こわくないbit全探索1 入門編: bit全探索ってなに？【競プロ解説】 - Qiita ","date":"Jan 09","permalink":"https://jikky.dev/post/bit%E5%85%A8%E6%8E%A2%E7%B4%A2%E3%81%AB%E3%81%A4%E3%81%84%E3%81%A6%E3%81%AE%E3%81%8A%E8%A9%B1/","tags":["競技プログラミング"],"title":"bit全探索についてのお話。"},{"categories":null,"contents":" Github: @Jikky1618 Twitter: @Jikky1618 AtCoder: Jikky1618 Scratch: @-Jikky- 今は競プロに熱中しすぎて、あんまり活動していません。 note: じっきー 色変記事などはこちらに投稿する予定です。 Discord: Jikky#1618 Scratch JPというScratcherが集まるサーバーを運営しています。 ","date":"Jan 08","permalink":"https://jikky.dev/contact/","tags":null,"title":"Contact"},{"categories":null,"contents":"","date":"Jan 01","permalink":"https://jikky.dev/articles/","tags":null,"title":"Articles"}]
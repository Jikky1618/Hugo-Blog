[{"categories":["競技プログラミング"],"contents":"bit全探索は競プロで探索アルゴリズムを初めて学ぶ人にとって最初の壁となると思います。僕自身も初めて学んだのがbit全探索であり、学ぶ際に色々苦労しました。\nこの記事では、そのbit全探索について数学用語のみの簡潔な説明だけではなく、分かりやすく説明したいと思います。なお、前提知識として2進数・10進数の基本知識、ビット演算(シフト演算、AND演算) が分かると、より理解が深まると思います。\nbit全探索とは まず、bit全探索について一言で説明すると\n$2^N$ 通りの $N$ 個のものから、いくつか選んだ組合せを全探索するアルゴリズム\nとなります。これだけ言われてもよくわからないと思うので、例を通して説明していきます。\nまずは例から $N$ 個のものから、いくつか選んだ組合せをいきなり考えるのは難しいので、 より簡単な例題1を考えましょう。\n例題1 【問題】\n3個の整数 $0,1,2$ が与えられたとき、その中からいくつか選ぶ方法を列挙せよ。\n頑張って表に書き出すと $8$ 通りあることが分かります。\nなぜ $8$ 通りなのかを知るために整数がどのように選ばれているのかを考えます。\n3個の整数 $0,1,2$ は\n$0$ を選ぶ or $0$ を選ばない $1$ を選ぶ or $1$ を選ばない $2$ を選ぶ or $2$ を選ばない の選択肢が存在します。つまり、1つの整数ごとに選択肢が2通り存在します。\nよって、表に書いた通り3個の整数の中からいくつか選ぶ方法は $2\\times2\\times2 = 2^3$ つまり $8$ 通り存在します。一般に $N$ 個のものからいくつか選ぶ方法は $2^N$ 通り存在することが知られています。\nこのような\n$N$ 個あるものから、それぞれ「選ぶ」「選ばない」などの1個のものにつき2通りある選択肢がある場合、 $2^N$ 通りあるいくつか選ぶ方法を全列挙する1 みたいな問題を実装するときにbit全探索を使うことで簡潔に実装することができます。\n続いて、こちらの例題2を考えていきます。\n例題2 【問題】\n$N$ 個の整数 $A_1,A_2, \\dots,A_N$ が与えられたとき、その中からいくつか選ぶ方法を列挙せよ。\n【制約】\n$N \\leq 20$\n例題2は例題1よりも $N$ の制約が緩くなりました。(例題1は $N=3$ の場合です)\nこの問題を愚直にforループで解こうとすると、$N$ 重のfor文が必要になります。また、 $N$ の値は変わるのでfor文の数を固定して書くことができません。\n1 2 3 4 5 6 7 8 9 10 11 for(int i = 0; i \u0026lt; 2; i++){ for(int j = 0; j \u0026lt; 2; j++){ for(int k = 0; k \u0026lt; 2; k++){ for(int l = 0; l \u0026lt; 2; l++){ for(int m = 0; m \u0026lt; 2; m++){ // ... for文の個数が分からない } } } } } ここで、bit全探索を使うと $N$ 重のfor文を書くことなく、簡単に実装できるようになります！早速、例題2を解くbit全探索を実装していきましょう。\nbit全探索の実装 どの問題においてもbit全探索の基本的な実装方針は以下の通りです。\n💡 方針 手順1: 「いくつか選ぶ方法」を2進数で表し、全探索しやすいように2進数→10進数に変換して整数値にする 手順2: 整数値→2進数に再び変換し、「いくつか選ぶ方法」を復元する 手順3: 復元した「いくつか選ぶ方法」について処理を行う 手順4: 手順1-3を $2^N$ 通り全てに行う すなわち、\n複数のものから「いくつか選ぶ方法」( $\\{0,2\\}$ など) 整数値( $5$ など) の2つを対応させることで、整数値で全探索を行えるようにしていきます。\nいくつか選ぶ方法を2進数で表す はじめに、「いくつか選ぶ方法」を2進数で表す方法を考えます。例えば、 $\\{0,1,2\\}$ に対して $\\{1,2\\}$ を選ぶ方法は\n1番目の $0$ : 選ばない 2番目の $1$ : 選ぶ 3番目の $2$ : 選ぶ となっており、これを2進数で復元するとき選ぶときを1、選ばないときを0とすると $N$ 桁の2進数で $110_{(2)}$ と表すことができます。つまり、\n$i$ 番目のものを選ぶなら、2進数の $i$ 桁目を1にする $i$ 番目のものを選ばないなら、2進数の $i$ 桁目を0にする だけで「いくつか選ぶ方法」を2進数で表すことができるのです！\n2進数→10進数の整数値に変換する 次に、選ぶ方法を表した2進数を10進数へと変換させ、整数値にします。\n0,1,2の8通りの選び方について、2進数と10進数の整数値ではこのように表すことができます。\nbit全探索するためのfor文 $2^N$ 個ある「いくつか選ぶ方法」1つ1つを整数値 $0,1,2,\u0026hellip;,2^N-1$ に対応したことでforループを用いて簡単に全探索することができます。以下のコードは変数bitを $0\\sim 2^N-1$ の範囲でforループを回しています。これは「いくつか選ぶ方法」を整数値に対応付けて全探索を行っていることを表しています。\n1 2 3 for(int bit = 0; bit \u0026lt; (1 \u0026lt;\u0026lt; N); bit++){ /* 「いくつか選ぶ方法」を整数値で表したものに対して処理 */ } コード内の 1 \u0026lt;\u0026lt; N は1をN桁左ビットシフトした値 = $2^N$ のことです。(ビットシフトの詳細はアルゴ式のこのページを見てください。) 整数値→2進数に変換し、選ぶ方法を復元する 「いくつか選ぶ方法」を整数値に対応させましたが、このままだと整数値が表している「いくつか選ぶ方法」がなにを選んだのかが分からないので、先程と逆のことを行い復元します。つまり、\n整数値 $0,1,2,\u0026hellip;,2^N-1$ を再び2進数で表す $1 \\leq i \\leq N$ を満たす $i$ について、2進数で表される「いくつか選ぶ方法」から「 $i$ 番目のものを選んだかどうか」を判定する ことを行います。以下のコードはまさに整数値から「いくつか選ぶ方法」を復元しているのです。\n1 2 3 4 // bitのi桁目(i番目のもの)は1(選んだ)かどうか if((bit \u0026gt;\u0026gt; i) \u0026amp; 1){ /* 選んだものに対して処理 */ } コード内の \u0026amp; は AND演算 のことです。 このコードを詳しく見ていきます。このif文は整数値 $0,1,2,\u0026hellip;,2^N-1$ それぞれについて、\n再び2進数で表したとき、 $i$ 桁目が1かどうか( $i$ 番目のものを選んだかどうか) を判定しています。\n例えば、$N=3,\\text{bit} = 5$ のとき、if((bit \u0026gt;\u0026gt; i) \u0026amp; 1) はどのように判定を行うのか考えます。\n$\\text{bit}$ を2進数で表すと $101_{(2)}$ になるので $i = 0,1,2$ のときの判定は以下の通りです。\ni (bit \u0026gt;\u0026gt; i) ((bit \u0026gt;\u0026gt; i) \u0026amp; 1) 判定 0 101 101 \u0026amp; 001 = 001 True 1 010 010 \u0026amp; 001 = 000 False 2 001 001 \u0026amp; 001 = 001 True (bit \u0026gt;\u0026gt; i)は2進数の $\\text{bit}$ を $i$ 桁右シフトした値であり、これと $1$ をAND演算で判定をすることで\n$\\text{bit}$ の $i$ 桁目の値が1のとき、True $\\text{bit}$ の $i$ 桁目の値が0のとき、False となります。実際は $1$ とAND演算することにより最下位bitを残して全て0にできるので、\n$\\text{bit}$ の $i$ 桁右シフトした値の最下位bitが1なら、True (最下位bit以外の全ての桁は0) $\\text{bit}$ の $i$ 桁右シフトした値の最下位bitが0なら、False (全ての桁は0) を判定していることになります。\nよって、「いくつか選ぶ方法」を復元するためには、以下のように先程の判定をforループで全てのものに対して行えば良いです。\n1 2 3 4 5 for(int i = 0; i \u0026lt; N; i++){ if((bit \u0026gt;\u0026gt; i) \u0026amp; 1){ /* 選んだものに対して処理 */ } } 以上のことを踏まえて例題2をbit全探索で実装すると以下の通りになります！\n実装 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; int main(){ // N: 何個のものについて考えているか // bit: 選び方の集合を表す整数値 int N; cin \u0026gt;\u0026gt; N; // 2^N通りの選び方を 0,1,2,...,2^N-1 の整数値に対応させ、全探索 for(int bit = 0; bit \u0026lt; (1 \u0026lt;\u0026lt; N); bit++){ // 選んだものを管理する配列S vector\u0026lt;int\u0026gt; S; // 各iに対して for(int i = 0; i \u0026lt; N; i++){ // bitのi桁目は1(選んだ)かどうか if((bit \u0026gt;\u0026gt; i) \u0026amp; 1){ S.push_back(i); // 選んだならSに追加する } } // 配列Sの出力 cout \u0026lt;\u0026lt; bit \u0026lt;\u0026lt; \u0026#34;: \u0026#34;; for(auto\u0026amp;\u0026amp; v: S) cout \u0026lt;\u0026lt; v \u0026lt;\u0026lt; \u0026#34; \u0026#34;; cout \u0026lt;\u0026lt; endl; } } 出力 1 2 3 4 5 6 7 8 0: 1: 0 2: 1 3: 0 1 4: 2 5: 0 2 6: 1 2 7: 0 1 2 if((bit \u0026gt;\u0026gt; i) \u0026amp; 1)はif(bit \u0026amp; (1 \u0026lt;\u0026lt; i))と書くこともできますが、本質は同じです。 また、2進数のbitに対して頻出な判定方法は以下の通りです。\n判定 書き方 bitの $i$ 桁目が1か if((bit \u0026gt;\u0026gt; i) \u0026amp; 1) bitの $i$ 桁目が1でないか if(!((bit \u0026gt;\u0026gt; i) \u0026amp; 1)) bitの1の個数 __builtin_popcount(bit) 計算量について この先、アルゴリズムを学んでいく上で避けて通れないのは計算量の存在です。(計算量については今回は説明を省略します。)\n「いくつか選ぶ方法」というのは $2^N$ 通りありますが、これは指数的に増加します。すなわち $N$ の値が大きくなると「いくつか選ぶ方法」の数は爆発的に増加します。具体的な処理にもよりますが、bit全探索が行えるのは $N \\leq 20$ くらいの小さい値が限界です。 bit全探索を行う際は制約に注意しましょう。\n計算量だと $O(N 2^N)$ となります。\n実践問題 それではここでいくつかの問題をbit全探索で解いてみましょう。\n部分和問題 https://algo-method.com/tasks/1083\n【問題】\n$N$ 個の整数 $A_0, A_1, \\dots ,A_{N-1}$ と、整数 $V$ が与えられます。\nこれらの整数の中から、いくつかの整数を選んで総和をとります。 総和を $V$ にすることが可能かどうかを判定してください。\n【制約】\n$1\\leq N\\leq 16$ $1\\leq V\\leq 10^8$ $1\\leq A_i\\leq V (0 \\leq i\\leq N-1)$ 部分和問題という超ド定番の問題です。\nbit全探索の解説記事だから、bit全探索で解くんだな～と分かってしまうのですが、一度0からこの問題の解法を考えましょう。\n解法 まず初めに制約を確認しましょう。\nここで分かる大事なことは\n$N \\leq 16$ と $N$ が非常に小さいこと $A_i \\leq 10^8$ と 整数1つ1つの値が大きいこと です。\nここで $N$ が非常に小さいことに注目します。このような非常に小さい制約が与えられたとき、全探索解法がないかを検討するのは典型考察です。\nするとこの問題は「いくつかの整数を選ぶ方法」さえ全列挙できれば解くことができます。 $N$ 個の整数の中からいくつかの整数を選ぶ方法は $2^N$ 通りありますが $N \\leq 16$ なので多くても $2^{16} = 65536$ 通りしかないです。よって、この問題はbit全探索で時間に余裕を持って求めることができます。実装については\nbit全探索の実装の方針のように、bit全探索でいくつかの整数を選ぶ方法を全探索する 選んだ整数の総和を求めて、その値が $V$ になるのかを判定する の2ステップでこの問題を解くことができます。\n※動的計画法(DP)をご存知の方であればこの問題もDPで解けることが分かると思いますが、今回は整数1つ1つの値が非常に大きいので計算量が $O(NV)$ となってしまい実行時間に間に合いません。(また、配列の要素数が最大の場合 $10^9$ を超えるのでMLE(メモリ制限超過)やRE(実行時エラー)が発生します。)\n実装 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; int main(){ // 入力 int N, V; cin \u0026gt;\u0026gt; N \u0026gt;\u0026gt; V; vector\u0026lt;int\u0026gt; A(N); for(int i = 0; i \u0026lt; N; i++) cin \u0026gt;\u0026gt; A[i]; // bit全探索で部分和を全て求める bool flag = false; // 可能かどうかを管理する変数flag for(int bit = 0; bit \u0026lt; (1 \u0026lt;\u0026lt; N); bit++){ int sum = 0; for(int i = 0; i \u0026lt; N; i++){ if((bit \u0026gt;\u0026gt; i) \u0026amp; 1){ // もしi番目を選んだなら sum += A[i]; // sumにA[i]を足す } } // 部分和とVが等しいか判定 if(sum == V) flag = true; } // 出力 if(flag) cout \u0026lt;\u0026lt; \u0026#34;Yes\u0026#34; \u0026lt;\u0026lt; endl; else cout \u0026lt;\u0026lt; \u0026#34;No\u0026#34; \u0026lt;\u0026lt; endl; } 先程の実装では、数字の「いくつか選ぶ方法」の配列Sを作成していましたが、実際の問題では配列Sを作成することはほとんどありません。その代わりに\n$0 \\leq i \u0026lt; N$ を満たす $i$ について、 $i$ 番目のものが $\\text{bit}$ に含まれているなら、 それに応じた処理をその場で行う 場合がほとんどです。今回の部分和問題では\n$i$ 番目のものを選んだかどうかを判定する 選んだなら変数sumに足す を同時に行う実装をしています。\nABC289 C - Coverage https://atcoder.jp/contests/abc289/tasks/abc289_c\n【問題】\n$1$ 以上 $N$ 以下の整数からなる集合が $M$ 個あり、 $S_1, S_2, \\dots ,S_{M}$ と呼びます。\n$S_i$ は $C_i$ 個の整数 $a_{i, 1}, a_{i, 2}, \\dots ,a_{i, C_i}$ からなります。\n$M$ 個の集合から $1$ 個以上の集合を選ぶ方法は $2^M - 1$ 通りあります。\nこのうち、次の条件を満たす選び方は何通りありますか？\n$1 \\leq x \\leq N$ を満たす全ての整数 $x$ に対して、選んだ集合の中に $x$ を含む集合が少なくとも $1$ 個存在する。\n【制約】\n$1\\leq N\\leq 10$ $1\\leq M\\leq 10$ $1\\leq C_i\\leq N$ $1\\leq A_{i, 1}\u0026lt; A_{i, 2}\u0026lt;\\dots\u0026lt; A_{i, C_i}\\leq N$ つい最近のABCで出たC問題ですが、まさかbit全探索が灰diffになるとは。。。と思いました。\n解法 問題文に「 $M$ 個の集合から $1$ 個以上の集合を選ぶ方法は $2^M - 1$ 通りあります」とご丁寧に書いてあるので、まず初めに $2^M$ 通りを全探索するbit全探索ができないかを検討してみます。\nここで $M$ の制約を見ると $M\\leq 10$ と 非常に小さい ため、多くても $2^{10} = 1024$ 通りしかないです。よって、この問題はbit全探索で時間に余裕を持って求めることができることが分かります。\nbit全探索することは分かりましたが、問題文の条件である\n$1 \\leq x \\leq N$ を満たす全ての整数 $x$ に対して、選んだ集合の中に $x$ を含む集合が少なくとも $1$ 個存在する ことを判定するにはどうすれば良いでしょうか。\nこの判定は set と呼ばれる重複を取り除いてくれるデータ構造を用いることで\n空のsetを用意する 選んだ集合に含まれている整数を全て1つの set に挿入する 挿入した後、 set に $1, 2, \\dots ,x$ が存在するかを判定する $\\Leftrightarrow$ set の要素数が $x$ 個かどうかを判定する ことで条件の判定を行うことができます！( set についてはAPG4bのAA - 3.03.STLのコンテナ内の細かい話欄を見てください。)\n以上よりこの問題は\nbit全探索で $M$ 個の集合から $1$ 個以上の集合を選ぶ方法を全探索する 選んだ集合が問題文の条件を満たすかを set を使って判定する 条件を満たす集合の選び方を数えて、その数を出力する ことで解くことができます！\n計算量についてですが、set の1回の挿入には $O(\\log N)$ の計算量が必要ですので、1つの集合の挿入には $O(N\\log N)$ 必要になります。よって最終的な計算量は $O(2^MNM\\log N)$ となります。\n実装 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; int main(){ // 入力 int N, M; cin \u0026gt;\u0026gt; N \u0026gt;\u0026gt; M; vector\u0026lt;int\u0026gt; C(M); vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; A(M); for(int i = 0; i \u0026lt; M; i++){ cin \u0026gt;\u0026gt; C[i]; A[i].resize(C[i]); // A[i]の長さをC[i]に変える for(int j = 0; j \u0026lt; C[i]; j++) cin \u0026gt;\u0026gt; A[i][j]; } // bit全探索で条件を満たす集合の選び方がいくつあるかを求める int ans = 0; // 何通りの選び方があるかを管理する変数ans for(int bit = 0; bit \u0026lt; (1 \u0026lt;\u0026lt; M); bit++){ // 空のsetを用意する set\u0026lt;int\u0026gt; st; for(int i = 0; i \u0026lt; M; i++){ if((bit \u0026gt;\u0026gt; i) \u0026amp; 1){ // もしi番目の集合を選んだなら for(int j = 0; j \u0026lt; C[i]; j++){ st.insert(A[i][j]); // i番目の集合の整数を全てsetに挿入する } } } // setに1, 2, ..., xが存在するかを判定 if(st.size() == N) ans++; } // 出力 cout \u0026lt;\u0026lt; ans \u0026lt;\u0026lt; endl; } さいごに 初めてで拙い文章になってしまいましたが、この記事で1人でもbit全探索の理解に繋がったのであれば嬉しいです。参考文献の記事も僕自身が学習する際に読んでいたものであり、今回の記事を書く際にたくさん参考にさせてもらいました。是非、そちらの記事も確認してみてください。\n練習問題 ビット演算 | アルゴ式 : ビットの説明からbit全探索まで全てをカバーしている素晴らしい問題集です。 bit全探索例題 : bit全探索で解けるAtCoderの問題の簡易的な説明と実装コードです。 参考文献 ビット演算 (bit 演算) の使い方を総特集！ 〜 マスクビットから bit DP まで 〜 - Qiita bit 全探索 - けんちょんの競プロ精進記録 ビット全探索（ 2^n 通りの全探索） | アルゴリズムロジック こわくないbit全探索1 入門編: bit全探索ってなに？【競プロ解説】 - Qiita $N$ 個の要素を持つ集合 $\\{0, 1, 2, \\dots, N-1\\}$ の部分集合を全列挙することと同じ意味です。\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n","date":"Jan 09","permalink":"https://jikky.dev/post/bit-search/","tags":["競技プログラミング","bit全探索"],"title":"bit全探索をココロから理解する"},{"categories":null,"contents":" Github: @Jikky1618 Twitter: @Jikky1618 AtCoder: Jikky1618 Scratch: @-Jikky- 今は競プロに熱中しすぎて、あんまり活動していません。 note: じっきー 色変記事などはこちらに投稿する予定です。 Discord: Jikky#1618 Scratch JPというScratcherが集まるサーバーを運営しています。 ","date":"Jan 08","permalink":"https://jikky.dev/contact/","tags":null,"title":"Contact"},{"categories":null,"contents":"","date":"Jan 01","permalink":"https://jikky.dev/articles/","tags":null,"title":"Articles"}]
---
title: "bit全探索についてココロから理解する"
date: 2023-01-09T08:36:58+09:00
description: ""
draft: false
tags:
- 競技プログラミング
categories:
- 競技プログラミング
katex: true
---

競技プログラミングでアルゴリズムを初めて学ぶ人にとって最初の壁となるのがbit全探索だと思います。僕自身、初めて学んだアルゴリズムがbit全探索であり、色々苦労しました。

この記事では、そのbit全探索について数学用語のみの簡潔な説明だけではなく、分かりやすく説明したいと思います。<br>
なお、前提知識として **2進数・10進数の基本知識** 、 **ビットの基本演算(シフト演算、AND演算)** を理解していると、より理解が深まると思います。

## はじめに

まず、bit全探索についてとても簡潔に説明すると以下のようになります。

> **$N$ 個の要素を持つ集合 $\\{0,1,2,\dots,N-1\\}$ の部分集合の全列挙を行うアルゴリズム**

「集合って何？部分集合の全列挙って何？」と思われた方がほとんどだと思いますが、安心してください。順を追って理解できるよう説明しますので、まずは簡単な例題で肩慣らしをしましょう。

### まずは例題から

手始めにforループでも解ける簡単な全探索の問題を考えましょう。

> 【問題】<br>
3個の整数 $0,1,2$ が与えられたとき、その中からいくつか選ぶ方法を列挙せよ。
>

この問題はどのように全探索をすれば良いでしょうか。まず、3個ある整数ごとに選択肢としてその数字を **「選ぶ」「選ばない」** の2通りの選択肢が存在します。 3個の整数 $0,1,2$ について

- $0$ を選ぶ or $0$ を選ばない
- $1$ を選ぶ or $1$ を選ばない
- $2$ を選ぶ or $2$ を選ばない

の選択肢が存在します。この3つの選択肢の組み合わせを全探索すればいいので、このような3重のforループを書くことにより全探索することができ、問題を解くことができました。

```cpp
int cnt = 1;
for(int i = 0; i < 2; i++){
    for(int j = 0; j < 2; j++){
        for(int k = 0; k < 2; k++){
            vector<int> S;
            if(k == 1) S.push_back(0);
            if(j == 1) S.push_back(1);
            if(i == 1) S.push_back(2);

            cout << cnt << ": ";
            for(auto&& s: S) cout << s << " ";
            cout << endl;

            cnt++;
        }
    }
}
```
```
1: 
2: 0 
3: 1
4: 0 1
5: 2
6: 0 2
7: 1 2
8: 0 1 2
```

## 結局、bit全探索はなんなのか

実は先程の例題はbit全探索の場合でも全く同じ方針で考えることができます。bit全探索は

- 複数あるものから **「選ぶ」「選ばない」** などの **2通りある選択肢の選び方がある場合**、あり得る選び方を全探索しなければならない問題

に使うことができるのです！<br>
先程は「3個の整数」から「選ぶ」「選ばない」の **2通りある選択肢の選び方** を全列挙しましたが、ここで、最初に示した説明を分かりやすくするとこうなります。

> **複数あるものから、「いくつか選ぶ方法」を全列挙して探索するアルゴリズム**

「いくつか選ぶ方法」の全列挙というのは  **複数あるものの各々について「選ぶ・選ばない」の組み合わせを全列挙する** ということです。
bit全探索の正体は **"全探索"と名前についてある通り、 ただの全探索を行うだけ** のアルゴリズムなのです！！！

具体例として、先程の例題の3つの整数0, 1, 2をいくつか選ぶ方法は下図のように $2^3 = 8$ 通りの組み合わせがあります。一般に $N$ 個のものから、いくつか選ぶ方法は $2^N$ 通りありますので覚えておきましょう。

{{< figure src="image1.png" width="500px" >}}

## bit全探索の実装

では、先程の例題をforループではなく、bit全探索で解いていきましょう。基本的にbit全探索を実装するときの方針は以下の通りです。

> &#x1f4a1; **方針** <br>
> 1. **「いくつか選ぶ方法」を2進数で表し、全探索しやすいように2進数→10進数に変換して整数値にする**
> 2. **整数値→2進数に再び変換し、「いくつか選ぶ方法」を復元する**
> 3. **復元した「いくつか選ぶ方法」について処理を行う**
> 4. **1-3を $2^N$ 通り全てに行う**

すなわち、

- 複数のものから「いくつか選ぶ方法」( $\\{0,2\\}$ など)
- 整数値( $5$ など)

を対応させることで全探索を簡単に行えるようにする、ということです！

### いくつか選ぶ方法を2進数で表す

はじめに、「いくつか選ぶ方法」を2進数で表す方法を考えます。

例えば、 $\\{0,1,2\\}$ に対して $\\{1,2\\}$ を選ぶ方法は

- 1番目の $0$ : 選ばない
- 2番目の $1$ : 選ぶ
- 3番目の $2$ : 選ぶ

となっており、これを2進数で復元するとき **選ぶときを1、選ばないときを0** とすると $N$ 桁の2進数で  $011_{(2)}$ と表すことができます。つまり、

- **$i$ 番目のものを選ぶなら、2進数の $i$ 桁目を1にする**
- **$i$ 番目のものを選ばないなら、2進数の $i$ 桁目を0にする**

だけで「いくつか選ぶ方法」を2進数で表すことができるようになったのです！

### 2進数→10進数の整数値に変換する

次に、選ぶ方法を表した2進数を10進数へと変換させ、整数値にします。整数値と対応することで非常に扱いやすくなり、全探索がしやすくなります！

例題の8通りの選び方について、2進数と10進数の整数値ではこのように表すことができます。

{{< figure src="image2.png" >}}

### bit全探索するためのfor文

$2^N$ 個ある「いくつか選ぶ方法」を整数値 $0,1,2,...,2^N-1$ にしたことでforループを用いて簡単に全探索することができます。bit全探索での以下の部分は「いくつか選ぶ方法」を整数値に対応付けて全探索を行っていることを表しているのです！

```cpp
for(int bit = 0; bit < (1 << N); bit++){
    /* 「いくつか選ぶ方法」を整数値で表したものに対して処理 */
}
```

- コード内の **`1 << N` は1をN桁左シフトした値 = $2^N$ のこと**です。

### 整数値→2進数に変換し、選ぶ方法を復元する

「いくつか選ぶ方法」を整数値に対応させましたが、このままだとその整数が「どう選ぶことを意味しているのか」が分からないので、先程と逆のことを行い復元します。つまり、

- 整数値 $0,1,2,...,2^N-1$ を再び2進数で表す
- 2進数で表される「いくつか選ぶ方法」において、 $1 \leq i \leq N$ を満たす $i$ について、「 $i$ 番目のものを選んだかどうか」を判定する

ことを行います。以下の部分は整数値から「いくつか選ぶ方法」を復元しているのです。

```cpp
// bitのi桁目(i番目のもの)は1(選んだ)かどうか
if((bit >> i) & 1){
    /* 選んだものに対して処理 */
}
```

このif文は整数値 $0,1,2,...,2^N-1$ それぞれについて、

- **再び2進数で表したとき、 $i$ 桁目が1かどうか( $i$ 番目のものを選んだかどうか)**

を判定しています。

例えば、$N=3,\text{bit} = 4$ のとき、`if((bit >> i) & 1)` はどのように判定を行うのか考えます。

$\text{bit}$ を2進数で表すと $101_{(2)}$ になるので $i = 0,1,2$ のときの判定は以下の通りです。

| i | `(bit >> i)` | `((bit >> i) & 1)` | 判定 |
| --- | --- | --- | --- |
| 0 | 101 | 101 & 001 = 001 | True |
| 1 | 010 | 010 & 001 = 000 | False |
| 2 | 001 | 001 & 001 = 001 | True |

`(bit >> i)`は2進数の $\text{bit}$ を $i$ 桁右シフトした値であり、これと $1$ をAND演算で判定をすることで

- **$ \text{bit}$ の $i$ 桁目の値が1のとき、True**
- **$ \text{bit}$ の $i$ 桁目の値が0のとき、False**

となります。実際は $1$ とAND演算することにより最下位bitを残して全て0にできるので、

- $ \text{bit}$ の $i$ 桁右シフトした値の最下位bitが1なら、True (最下位bit以外の全ての桁は0)
- $ \text{bit}$ の $i$ 桁右シフトした値の最下位bitが0なら、False (全ての桁は0)

と判定していることになります。

よって、「いくつか選ぶ方法」を復元するためには、以下のように先程の判定をforループで全てのものに対して行えば良いです。

```cpp
for(int i = 0; i < N; i++){
    if((bit >> i) & 1){
        /* 選んだものに対して処理 */
    }
}

```

## 実装

長くなりましたが、最初の例題をbit全探索で実装すると以下の通りになります！ 


```cpp
// N: 何個のものについて考えているか
// bit: 選び方の集合を表す整数値
int N = 3; // 3つの整数についてなので N = 3

// 2^N通りの選び方を 0,1,2,...,2^N-1 の整数値に対応させ、全探索
for(int bit = 0; bit < (1 << N); bit++){

    // 2進数で表した「いくつか選ぶ方法」Sを求める
    vector<int> S;

    // 各iに対して
    for(int i = 0; i < N; i++){
        // bitのi桁目は1(選んだ)かどうか
        if((bit >> i) & 1){
            S.push_back(i); // 選んだならSに追加する
        }
    }

    // 「いくつか選ぶ方法」Sの出力
    cout << bit << ": ";
    for(auto&& v: S) cout << v << " ";
    cout << endl;
}
```

```
0: 
1: 0 
2: 1
3: 0 1
4: 2
5: 0 2
6: 1 2
7: 0 1 2
```

- `if((bit >> i) & 1)`は`if(bit & (1 << i))`と書くこともできますが、本質は同じです。
- 実際の問題では配列Sを作成することはほとんどありませんが、その代わりに
    - 各 $i = 0, 1,\dots ,N-1$ に対して
    - $i$ が2進数で表される「いくつか選ぶ方法」に含まれていることが分かったら
    - それに応じた処理をその場で行う
    
    という場合がほとんどです。

また、他にも2進数のbitに対して頻出な判定の書き方は以下の通りです。

| 判定 | 書き方 |
| --- | --- |
| bitのi桁目が1かどうか<br>(i番目を選んだかどうか) | `if((bit >> i) & 1)` |
| bitのi桁目が1ではないかどうか<br>(i番目を選んでいないかどうか) | `if(!((bit >> i) & 1))` |
| bitの1の個数<br>(選んだ個数) | `__builtin_popcount(bit)` |

##### 計算量について
この先、アルゴリズムを学んでいく上で避けては通れないのは **計算量** の存在です。(計算量については今回は説明を省略します。)

「いくつか選ぶ方法」というのは $2^N$ 通りありますが、すなわち $N$ の値が大きくなると「いくつか選ぶ方法」の数も爆発的に増加するということになります。具体的な処理にもよりますが、 **bit全探索が行えるのは $N \leq 20$ くらいの小さい $N$ が限界です。** <br>
計算量だと $O(N 2^N)$ となります。

<!-- ## 実践問題

一通りbit全探索について理解したところで1問、bit全探索で解いてみましょう。

### 部分和問題
https://algo-method.com/tasks/1083

> 【問題】<br>
$N$ 個の整数 $A_0, A_1, \dots ,A_{N-1}$ と、整数 $V$ が与えられます。
これらの整数の中から、いくつかの整数を選んで総和をとります。 総和を $V$ にすることが可能かどうかを判定してください。<br>
【制約】<br>
> - $ 1\leq N\leq 16$
> - $1\leq V\leq 10^8$
> - $1\leq A_i\leq V (0 \leq i\leq N-1)$
>

部分和問題という超ド定番の問題です。これを今回はbit全探索を用いて解いていきましょう。 -->



## 練習問題

bit全探索で解ける問題を置いておきます。 [bit全探索例題](https://jikky.notion.site/bit-6f60d4392c394b3fa4d49fdeb14c822a) 

## 参考文献

- **[ビット演算 (bit 演算) の使い方を総特集！ 〜 マスクビットから bit DP まで 〜 - Qiita](https://qiita.com/drken/items/7c6ff2aa4d8fce1c9361)**
- [**bit 全探索 - けんちょんの競プロ精進記録**](https://drken1215.hatenablog.com/entry/2019/12/14/171657)
- **[ビット全探索（ 2^n 通りの全探索） | アルゴリズムロジック](https://algo-logic.info/rec-bit-search/)**
- **[こわくないbit全探索1 入門編: bit全探索ってなに？【競プロ解説】 - Qiita](https://qiita.com/u2dayo/items/68e35815659b1041c3c2)**
---
title: "bit全探索をココロから理解する"
date: 2023-01-09T08:36:58+09:00
description: ""
draft: false
tags:
- 競技プログラミング
categories:
- 競技プログラミング
katex: true
---

競技プログラミングでアルゴリズムを初めて学ぶ人にとって最初の壁となるのがbit全探索だと思います。僕自身、初めて学んだアルゴリズムがbit全探索であり、色々苦労しました。

この記事では、そのbit全探索について数学用語のみの簡潔な説明だけではなく、分かりやすく説明したいと思います。<br>
なお、前提知識として **2進数・10進数の基本知識** 、 **ビットの基本演算(シフト演算、AND演算)** を理解していると、より理解が深まると思います。

## はじめに

まず、bit全探索について一言で説明すると

> **複数あるものから、「いくつか選ぶ方法」を全列挙して探索するアルゴリズム**

となります。これから2つの例題を通して、bit全探索のイメージをつかんでいきましょう。

### まずは例題から

手始めに **例題1** を考えましょう。

##### 例題1

> 【問題】<br>
3個の整数 $0,1,2$ が与えられたとき、その中からいくつか選ぶ方法を列挙せよ。
>

分かりやすく表に書き出すと $8$ 通りあることが分かります。

{{< figure src="image1.png" width="500px" >}}

この選び方をプログラムでどのように列挙をすれば良いでしょうか。<br>
この場合、選び方を列挙する単純な方法としてforループを使うことができます。

3個の整数 $0,1,2$ について

- $0$ を選ぶ or $0$ を選ばない
- $1$ を選ぶ or $1$ を選ばない
- $2$ を選ぶ or $2$ を選ばない

の選択肢が存在します。<br>
つまり、数字を **「選ぶ」「選ばない」** の2通りの選択肢が3つあるので、 $2^3 = 8$ 通りを列挙すれば良いことになります。

よって、以下のような3重のforループを書くことで全て列挙することができ、この問題を解くことができます。

```cpp
int cnt = 1;
// 数字2の「選ばない」「選ぶ」を全探索
for(int i = 0; i < 2; i++){
    // 数字1の「選ばない」「選ぶ」を全探索
    for(int j = 0; j < 2; j++){
        // 数字0の「選ばない」「選ぶ」を全探索
        for(int k = 0; k < 2; k++){
            vector<int> S; // 選んだものを管理する配列S

            // もし選んだならSに追加
            if(k == 1) S.push_back(0);
            if(j == 1) S.push_back(1);
            if(i == 1) S.push_back(2);

            // 配列Sの出力
            cout << cnt << ": ";
            for(auto&& s: S) cout << s << " ";
            cout << endl;

            cnt++; // カウントを1つ増やす
        }
    }
}
```
```
1: 
2: 0 
3: 1
4: 0 1
5: 2
6: 0 2
7: 1 2
8: 0 1 2
```

## 結局、bit全探索はなんなのか

例題1はforループで全探索しましたが、実は<>bit全探索の場合でも全く同じ方針で全探索をすることができます。bit全探索が使える条件は

- 複数あるものから **「選ぶ」「選ばない」** などの **2通りある選択肢の選び方がある場合**、あり得る選び方を全探索しなければならない問題

に使うことができます！

例題1では「3個の整数」から「選ぶ」「選ばない」の **2通りある選択肢の選び方** を全列挙しましたが、より一般的には **複数あるものの各々について「選ぶ・選ばない」の組み合わせを全列挙する** ことができます。

また、**一般に $N$ 個のものからいくつか選ぶ方法は $2^N$ 通りあります。**<br>
ですので、先程の条件を言い換えると

 - $2^N$ 通りある「いくつか選ぶ方法」を全探索しなければならない問題

に使うことができます。<br>
結局のところ、bit全探索の正体は **"全探索"と名前についてある通り、全探索を行うだけ** のとってもシンプルなアルゴリズムなのです！！！

### forループでは解けない問題

次にこちらの例題2を考えていきます。

##### 例題2

> 【問題】<br>
$N$ 個の整数 $A_1,A_2, \dots,A_N$ が与えられたとき、その中からいくつか選ぶ方法を列挙せよ。<br>【制約】<br>$N \leq 20$
> 

例題2は例題1よりも $N$ の制約が緩くなりました。(例題1は $N=3$ の場合です)<br>
この問題を先程と同じようにforループで解こうとすると、$N$ 重のfor文が必要になります。また、 $N$ の値は変わるのでfor文の数を固定して書くことができません。

```cpp
for(int i = 0; i < 2; i++){
    for(int j = 0; j < 2; j++){
        for(int k = 0; k < 2; k++){
            for(int l = 0; l < 2; l++){
                for(int m = 0; m < 2; m++){
                    // ... これでは解くことができない
                }
            }
        }
    }
}
```

では、例題2はどのようにして解けば良いのでしょうか。<br>
先程、bit全探索は **$2^N$ 通りの「いくつか選ぶ方法」を全探索しなければならない問題** に使うことができると説明しましたが、この $N$ の数が **入力によって変化する場合** でもbit全探索は使うことができます！

## bit全探索の実装

早速、例題2を解くためのbit全探索を実装していきましょう。基本的な実装方針は以下の通りです。

> &#x1f4a1; **方針** <br>
> - 手順1: **「いくつか選ぶ方法」を2進数で表し、全探索しやすいように2進数→10進数に変換して整数値にする**
> - 手順2: **整数値→2進数に再び変換し、「いくつか選ぶ方法」を復元する**
> - 手順3: **復元した「いくつか選ぶ方法」について処理を行う**
> - 手順4: **手順1-3を $2^N$ 通り全てに行う**

すなわち、

- 複数のものから「いくつか選ぶ方法」( $\\{0,2\\}$ など)
- 整数値( $5$ など)

の2つを対応させることで、整数値で全探索を行えるようにしていきます。

### いくつか選ぶ方法を2進数で表す

はじめに、「いくつか選ぶ方法」を2進数で表す方法を考えます。例えば、 $\\{0,1,2\\}$ に対して $\\{1,2\\}$ を選ぶ方法は

- 1番目の $0$ : 選ばない
- 2番目の $1$ : 選ぶ
- 3番目の $2$ : 選ぶ

となっており、これを2進数で復元するとき **選ぶときを1、選ばないときを0** とすると $N$ 桁の2進数で  $110_{(2)}$ と表すことができます。つまり、

- **$i$ 番目のものを選ぶなら、2進数の $i$ 桁目を1にする**
- **$i$ 番目のものを選ばないなら、2進数の $i$ 桁目を0にする**

だけで「いくつか選ぶ方法」を2進数で表すことができるようになったのです！

### 2進数→10進数の整数値に変換する

次に、選ぶ方法を表した2進数を10進数へと変換させ、整数値にします。<br>
0,1,2の8通りの選び方について、2進数と10進数の整数値ではこのように表すことができます。

{{< figure src="image2.png" >}}

### bit全探索するためのfor文

$2^N$ 個ある「いくつか選ぶ方法」1つ1つを整数値 $0,1,2,...,2^N-1$ に対応したことでforループを用いて簡単に全探索することができます。以下の部分は「いくつか選ぶ方法」を整数値に対応付けて全探索を行っていることを表しています。

```cpp
for(int bit = 0; bit < (1 << N); bit++){
    /* 「いくつか選ぶ方法」を整数値で表したものに対して処理 */
}
```

- コード内の **`1 << N` は1をN桁左シフトした値 = $2^N$ のこと**です。

### 整数値→2進数に変換し、選ぶ方法を復元する

「いくつか選ぶ方法」を整数値に対応させましたが、このままだとその整数が「どう選ぶことを意味しているのか」が分からないので、先程と逆のことを行い復元します。つまり、

- 整数値 $0,1,2,...,2^N-1$ を再び2進数で表す
- 2進数で表される「いくつか選ぶ方法」において、 $1 \leq i \leq N$ を満たす $i$ について、「 $i$ 番目のものを選んだかどうか」を判定する

ことを行います。以下の部分は整数値から「いくつか選ぶ方法」を復元しているのです。

```cpp
// bitのi桁目(i番目のもの)は1(選んだ)かどうか
if((bit >> i) & 1){
    /* 選んだものに対して処理 */
}
```

このif文は整数値 $0,1,2,...,2^N-1$ それぞれについて、

- **再び2進数で表したとき、 $i$ 桁目が1かどうか( $i$ 番目のものを選んだかどうか)**

を判定しています。

例えば、$N=3,\text{bit} = 5$ のとき、`if((bit >> i) & 1)` はどのように判定を行うのか考えます。

$\text{bit}$ を2進数で表すと $101_{(2)}$ になるので $i = 0,1,2$ のときの判定は以下の通りです。

| i | `(bit >> i)` | `((bit >> i) & 1)` | 判定 |
| --- | --- | --- | --- |
| 0 | 101 | 101 & 001 = 001 | True |
| 1 | 010 | 010 & 001 = 000 | False |
| 2 | 001 | 001 & 001 = 001 | True |

`(bit >> i)`は2進数の $\text{bit}$ を $i$ 桁右シフトした値であり、これと $1$ をAND演算で判定をすることで

- **$ \text{bit}$ の $i$ 桁目の値が1のとき、True**
- **$ \text{bit}$ の $i$ 桁目の値が0のとき、False**

となります。実際は $1$ とAND演算することにより最下位bitを残して全て0にできるので、

- $ \text{bit}$ の $i$ 桁右シフトした値の最下位bitが1なら、True (最下位bit以外の全ての桁は0)
- $ \text{bit}$ の $i$ 桁右シフトした値の最下位bitが0なら、False (全ての桁は0)

と判定していることになります。

よって、「いくつか選ぶ方法」を復元するためには、以下のように先程の判定をforループで全てのものに対して行えば良いです。

```cpp
for(int i = 0; i < N; i++){
    if((bit >> i) & 1){
        /* 選んだものに対して処理 */
    }
}

```

## 実装

長くなりましたが、例題をbit全探索で実装すると以下の通りになります！ 


```cpp
// N: 何個のものについて考えているか
// bit: 選び方の集合を表す整数値
int N = 3; // 3つの整数についてなので N = 3

// 2^N通りの選び方を 0,1,2,...,2^N-1 の整数値に対応させ、全探索
for(int bit = 0; bit < (1 << N); bit++){

    // 選んだものを管理する配列S
    vector<int> S;

    // 各iに対して
    for(int i = 0; i < N; i++){
        // bitのi桁目は1(選んだ)かどうか
        if((bit >> i) & 1){
            S.push_back(i); // 選んだならSに追加する
        }
    }

    // 配列Sの出力
    cout << bit << ": ";
    for(auto&& v: S) cout << v << " ";
    cout << endl;
}
```

```
0: 
1: 0 
2: 1
3: 0 1
4: 2
5: 0 2
6: 1 2
7: 0 1 2
```

- `if((bit >> i) & 1)`は`if(bit & (1 << i))`と書くこともできますが、本質は同じです。
- 実際の問題では配列Sを作成することはほとんどありませんが、その代わりに
    - 各 $i = 0, 1,\dots ,N-1$ に対して
    - $i$ が2進数で表される「いくつか選ぶ方法」に含まれていることが分かったら
    - それに応じた処理をその場で行う
    
    という場合がほとんどです。

また、他にも2進数のbitに対して頻出な判定の書き方は以下の通りです。

| 判定 | 書き方 |
| --- | --- |
| bitの $i$ 桁目が1か | `if((bit >> i) & 1)` |
| bitの $i$ 桁目が1でないか | `if(!((bit >> i) & 1))` |
| bitの1の個数 | `__builtin_popcount(bit)` |

##### 計算量について
この先、アルゴリズムを学んでいく上で避けては通れないのは **計算量** の存在です。(計算量については今回は説明を省略します。)

「いくつか選ぶ方法」というのは $2^N$ 通りありますが、すなわち $N$ の値が大きくなると「いくつか選ぶ方法」の数も爆発的に増加するということになります。具体的な処理にもよりますが、 **bit全探索が行えるのは $N \leq 20$ くらいの小さい $N$ が限界です。** <br>
計算量だと $O(N 2^N)$ となります。

## 実践問題

一通りbit全探索について理解したところで1問、bit全探索で解いてみましょう。

### 部分和問題
https://algo-method.com/tasks/1083

> 【問題】<br>
$N$ 個の整数 $A_0, A_1, \dots ,A_{N-1}$ と、整数 $V$ が与えられます。
これらの整数の中から、いくつかの整数を選んで総和をとります。 総和を $V$ にすることが可能かどうかを判定してください。<br>
【制約】<br>
> - $ 1\leq N\leq 16$
> - $1\leq V\leq 10^8$
> - $1\leq A_i\leq V (0 \leq i\leq N-1)$
>

部分和問題という超ド定番の問題です。これを今回はbit全探索を用いて解いていきましょう。<br>
$N$ 個の整数の中からいくつかの整数を選ぶ方法は $2^N$ 通りあるので、bit全探索が使えるということになります。

 - bit全探索でいくつかの整数を選ぶ方法を全探索する
 - 選んだ整数の総和を求めて、その値が $V$ になるのかを判定する

の2ステップでこの問題を解くことができます。

```cpp
#include <bits/stdc++.h>
using namespace std;

int main(){
    // 入力
    int N, V;
    cin >> N >> V;
    vector<int> A(N);
    for(int i = 0; i < N; i++) cin >> A[i];

    // bit全探索で部分和を全て求める
    bool flag = false; // 可能かどうかを管理する変数flag
    for(int bit = 0; bit < (1 << N); bit++){
        int sum = 0;
        for(int i = 0; i < N; i++){
            if((bit >> i) & 1){ // もしi番目を選んだなら
                sum += A[i]; // sumにA_iを足す
            }
        }

        // 部分和とVが等しいか判定
        if(sum == V) flag = true;
    }

    // 出力
    if(flag) cout << "Yes" << endl;
    else cout << "No" << endl;
}
```

先程の実装では、数字の「いくつか選ぶ方法」の配列Sを作成していましたが、

 - $i$ 番目のものを選んだかどうか」を判定する
 - 選んだなら変数`sum`に足す(処理を行う)

を同時に行う実装をするのが自然です。



## 練習問題

bit全探索で解ける問題を置いておきます。 [bit全探索例題](https://jikky.notion.site/bit-6f60d4392c394b3fa4d49fdeb14c822a) 

## 参考文献

- **[ビット演算 (bit 演算) の使い方を総特集！ 〜 マスクビットから bit DP まで 〜 - Qiita](https://qiita.com/drken/items/7c6ff2aa4d8fce1c9361)**
- [**bit 全探索 - けんちょんの競プロ精進記録**](https://drken1215.hatenablog.com/entry/2019/12/14/171657)
- **[ビット全探索（ 2^n 通りの全探索） | アルゴリズムロジック](https://algo-logic.info/rec-bit-search/)**
- **[こわくないbit全探索1 入門編: bit全探索ってなに？【競プロ解説】 - Qiita](https://qiita.com/u2dayo/items/68e35815659b1041c3c2)**